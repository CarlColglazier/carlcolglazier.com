# -*- eval: (org-hugo-auto-export-mode 1); -*-
#+hugo_base_dir: ../
#+hugo_front_matter_format: yaml
#+hugo_section: notes

* TODO Speaking into the Void
  :PROPERTIES:
  :EXPORT_FILE_NAME: speaking-into-the-void
  :EXPORT_DATE: 2019-06-20
  :END:
How do we measure...well, anything? In research design, /operationalization/ describes how we transform the intangible into a measurable variable. How do you measure an abstract concept like violence or happiness? The trick is to tally some other variable which closely correlates with the desired variable.

Of course, any such measure isn't going to be perfect. In fact, bad assumptions in the operationalizations can easily throw everything off. This is often the step where research gets messy. By definition, if the construct could be empirically measured, an operationalization wouldn't be necessary in the first place. This leaves open room for a disconnect, which risks pushing the researcher toward an incorrect conclusion.

Take this example. You want to know how much I like the taste of coffee. To measure this, you take samples of my coffee consumption over time. The assumption behind this operationalization is that the more I like the taste of coffee, the more I would consume. Now if you sampled my beverage consumption some weeks, you might conclude that I don't like coffee at all: bodies are fragile things and sometimes I must forgo my daily cup(s)-of-joe for my health. Do my periods avoiding coffee mean I don't like it? Hardly, but if we tried to measure enjoyment of a beverage through these samples, we might end up reaching the wrong conclusion: that I don't like coffee [fn:enjoyment], when in reality I am just avoiding the potential for acid reflux.
** What's the goal?
Operationalization becomes particularly important when orginizations handle large quantities of data at scale. At a certain point, data become too overwhelming for a system based on manual decision-making. The usual response is automation, which can have unconsidered second-order effects.

A few years ago, YouTube made a big change when they changed what they mean by a "view". The site used to run rampant with clickbait content that people would only watch for maybe a few seconds at most. Because views were /the/ important measure and because even the shortest watch-time counted for a view, this incentivized some to create a lot of bad content---the kind that people would click away from within seconds. In short, YouTube's operationalization for views encouraged spam and click-bait.

They changed this several years ago, making their definition more subtle and contextual. You might notice that I'm being pretty vague here. That's intentional as YouTube is intentionally vague on the definition of a view themselves. After all, if they told people their precise methods, that would make it easier to cheat.

Views, however, are no longer king on the site. Instead, YouTube has moved toward "time watched" as its primary metric. This is harder to game and has the consequence of rewarding videos that keep people glued to the site for longer periods of time.

This thought dump goes back to motivation. Why do I write? Why do I
post online? Who is my audience and what do they (and I) want?

If there is one thing I've learned about myself, it is that I can be
highly motivated by boredom. I'm happiest with my mind engaged on
solving some problem---even one of my own creation. So that's kind of
what I plan to do, at least for the time being. I think there's a hugo
pressure in many online spaces to reduce yourself to a brand.
YouTube, for instance, [[https://creatoracademy.youtube.com/page/lesson/niche][suggests channels discover and stick to a
specific niche]]. Fair advice if you are trying to grow on the platform,
but this approach may not be best for everyone.

In my head, my niche is very broad: media. It's what I study and my
primary personal interest as well. A lot of things fit in that label:
I define media as tools which transform our view of space and time.
This is pretty broad[fn:innis]. I see the overlap, but it's less clear
if anyone else would. No matter.
** Who sets the goal?
It's easy to simply chase goals without realizing it. What is the "goal" of a place like Facebook? 

[fn:enjoyment] You could make the counterargument here that enjoyment includes the entire experience of consumption. In this case, it would include the potential for acid reflux, which is enough to sour the entire experience. This is a fair point!

[fn:innis] And this is also clearly inspired by Harold Innis.

* Waiting for Upstream
  :PROPERTIES:
  :EXPORT_FILE_NAME: waiting-for-upstream
  :EXPORT_DATE: 2019-06-20
  :END:
This is a post about this website. It's also a small reflection on software development. Enjoy.

---

This website has always relied on JavaScript in some way. At the moment, very little runs on the site itself outside specialty pages, but JavaScript always been central to the build process. Gulp, grunt, just plain npm---I think I've tried all of them at some point.
But as of this note, JavaScript is no longer a part of the build process. Here is how I did it.

Software with a large community of contributors brings further advantages. I obviously was not the only person using JavaScript for my minification workflow. On the Hugo repository, the [[https://github.com/gohugoio/hugo/issues/1251]["Support for minification of generated HTML files"]] issue was first started in 2015, around the same time I switched to Hugo. It was implemented in 2018 after a pretty extensive discussion. I should emphasize that I played absolutely no part in this process. I had a need shared with some others and I got to completely ride free off of their upstream contributions to the software I use. Others also wrote up the documentation that alerted me to this feature in the first place.

This is why popular software brings several advantages beyond their feature set. With a dedicated community, you get expanded documentation and more spaces to find help without any additional effort on your part. Your unusual workflow or edge-cases are more likely to be shared with someone else.

Software should not be evaluated on popularity alone; however, I do think it should be a factor. After all, it would seem quite the waste to throw out the fruits of popular collaboration.
* TODO Software on Patreon

- https://www.patreon.com/evanyou
- 
* A Fast from Electron: Streaming Music through MPD
  :PROPERTIES:
  :EXPORT_FILE_NAME: electron-fast
  :EXPORT_DATE: 2019-06-13
  :END:
Enough has been written on Electron's shortfalls that I feel no need to add my own gripes. Generally, I try to avoid it as much as possible. I'm sure the Discord desktop client is nice, but it also works just fine in my web browser. Slack? Okay, but you're only allowed on the work computer!

Despite my hesitations, one Electron app has constantly followed me around for years: the unofficial Google Play Music desktop player. Before you ask, no, I don't use Spotify. I do think it's the better-designed service, but GPM has a good family plan though and it comes with YouTube Red, which is a nice bonus.

Because of this setup, I basically have had a Chromium browser open on my computer at all times just to play music. What's the point of having 20 GB of RAM if I'm not trying to minimize its use at all times?

Here's what I'm using now instead:
- [[https://github.com/gmusicproxy/gmusicproxy][gmusicproxy]]
- [[https://www.musicpd.org/][Music Player Daemon (MPD)]]
- [[https://github.com/MusicPlayerDaemon/mpdscribble][mpdscribble]]
- [[https://rybczak.net/ncmpcpp/][NCurses Music Player Client (Plus Plus)]]

The only real pain point in my workflow is searching for new albums which are not already in my playlists. I might write a simple program for that at some point.

Bonus: my scrobbles now cache if there is ever a connectivity issue.
* Principles for Creative Work
  :PROPERTIES:
  :EXPORT_FILE_NAME: creative-work-principles
  :EXPORT_DATE: 2019-06-06
  :END:

A lot of these ideas aren't original. In fact, many are borrowed from
processes in software development and team management I have learned
while a college student. I am writing them down here as a bit of a
self-reminder. This note isn't perfect, but....
** Perfection is a fantasy

Don't fall for it.

The idea of perfection comes the imagination: an unrealistic,
idealized version of ourselves with no basis in reality.  Most of the
time, "good enough" is good enough. The goal should never be
perfection.  Rather, ask what you are trying to convey? How do you
want people to feel? What do you want them to know? If you can say
you've put to form what you want the audience to experience, you have
succeeded.

Otherwise...

** Build quickly and fail cheaply.

I wrote this up as one principle because I think they are necessarily
linked to each other.  As a recovering perfectionist, I remain
astutely aware of failure. It's inevitable in nearly any project. The
best way to manage it is to incorporate it into the process. Create
opportunities to flesh out ideas and prototypes to avoid racking up
higher costs later on.

** Reduce workflow friction.

How much time are you actually working and how much time do you spend
on paperwork? This isn't to say documentation is useless.
Coordination and teamwork often are exactly the bottlenecks which need
to be eliminated.

** It's easiest after you start.

I did summer swim team for many years. In May and early June, getting
into the water was a real drudge. The air wasn't quite warm enough for
it to feel refreshing and the water hadn't warmed up enough from its
chilly tapwater origins. The thing is, you could spend forever building
everything up, waiting at the side of the pool. Trying to amp yourself
up. It gets you nowhere. The only way to get through it is to get started.
It sucks, but you get better at managing it.
